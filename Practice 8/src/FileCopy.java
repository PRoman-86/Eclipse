/* Напишите программу копирования файлов под названием FileCopy, объединив для
этого фрагменты кода из раздела про байтовые потоки.
Откройте два потока (ввода и вывода) и вызовите методы read() и write() в
одном и том же цикле.
Используйте аргументы командной строки для передачи
программе имён исходного и конечного
файлов, например: java FileCopy c:\\temp\\scores.txt
c:\\backup\\scores2.txt
*/

import java.io.IOException; import java.io.BufferedInputStream;
import java.io.BufferedOutputStream; import java.io.FileInputStream;
import java.io.FileOutputStream;
//программа должна запускаться из командной строки и указанием аргументов
//либо в Eclipse через конфигурацию запуска
public class FileCopy {

	public static void main(String[] args) {
		
		/*
		 Создаем условие, при котором программа будет работать при условии,
		 что количество аргументов при запуске будет равно двум.
		 */
		if (args.length!=2) {
			System.out.println("Некорректный ввод аргументов командной строки:" + "\n программа копирования завершает работу.");
			System.exit(0); //завершение работы программы
		} else {
			System.out.println("Аргументы указаны верно, идет копирование файла...");
		}
		/*
		 Создаем переменные для хранения экземпляров потоков.
		 Переменная bit типа String существует для реализации дополнительных
		 опций и не нужна по заданию.
		 */
		FileInputStream srcFile=null; BufferedInputStream srcBuff=null;
		FileOutputStream finFile=null; BufferedOutputStream finBuff=null;
		String bit;
		
		try {
			/*
			 Открываем байтовые потоки для считывания исходного файла и записи
			 файла-копии. Буферизируем их, хотя в задании такого условия нет,
			 но так будет лучше :)
			 Аргументы в конструкторах указывают на введенные аргументы в командной строке
			 при запуске. Нулевой элемент массива указывает на исходный файл, а первый
			 элемент - соотв. на копию.
			 */
			srcFile=new FileInputStream(args[0]); srcBuff=new BufferedInputStream(srcFile);
			finFile=new FileOutputStream(args[1]); finBuff=new BufferedOutputStream(finFile);
			
			/*
			 Далее идет "вечный" цикл для побайтового считывания\записи файлов источника и копии.
			 Переменная inputBytes в каждый проход цикла хранит байт (значение от 0 до 255) информации из файла. В
			 следующий проход - следующий за ним байт и так далее; реализовано это с помощью 
			 метода read(), работающего с буферизированным потоком исходного файла.
			 
			 Далее в теле цикла идет условие, при котором переменная inputBytes сравнивается по значению с
			 отрицательным значением -1. inputBytes примет это значение в том случае, если файл
			 закончится. И программа с помощью break выйдет из цикла.
			 
			 Далее в теле цикла идет строка, реализующая побайтовую запись файла-копии с помощью
			 метода wtite(), работающего с буферизированным потоком файла-копии. Аргумент метода
			 содержит переменную с текущим байтом.
			 
			 Если реализовать одну из "закомментированных" строк, то программа во время копирования будет
			 выводить на экран содержимое файла либо в байтах, либо в битах. Это опционально, так как в
			 задании этого не было. В случае с байтами метод print() выводит через пробел значение
			 переменной inputBytes, а вот в случае с битами в бой вступает та самая ранее объявленная переменная
			 bit типа String, которая принимает String-значение, возвращаемое методом toBits() с аргументом
			 int-переменной inputBytes. Переменная bit хранит каждый бит файла и затем выводится на экран.
			 */
			while (true) {
				
				int inputBytes=srcBuff.read();
				//System.out.print(inputBytes+" "); //вывод в байтах
				//bit=toBits(inputBytes); System.out.print(bit+" "); //вывод в битах
				if (inputBytes==-1) break;
				finBuff.write(inputBytes);
			
			} //конец цикла
			
			//сообщение о завершении копирования и завершение работы программы
			System.out.println("Копирование файла завершено, работа программы завершена.");
			System.exit(0);
			
			//обработка исключения, в случае проблем с чтением-записью файлов
		} catch (IOException e) {
			System.out.println("Ошибка ввода-вывода"); e.printStackTrace();
		} finally {
			try {
				//закрываем все потоки
				finBuff.flush();
				srcFile.close(); finFile.close(); srcBuff.close(); finBuff.close();
				//обрабатываем исключение, связанное с методом close()
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}

	} //конец метода main()
	
	/*
	 Реализуем честно спизженный из интернета метод toBits(), который переводит
	 байты из десятичной системы в двоичную. Метод в аргументе получает значение
	 переменной inputBytes, которая локально представлена внутри метода
	 int-константой val. Возвращает метод String-значение, которое возьмет на себя
	 переменная bit выше.
	 */
	public String toBits(final int val) {
		 final StringBuilder result = new StringBuilder(); 
		for (int i=0; i<8; i++) { 
		result.append((int)(val >> (8-(i+1)) & 0x0001)); 
		} 
		return result.toString();
		} 

} //конец класса
